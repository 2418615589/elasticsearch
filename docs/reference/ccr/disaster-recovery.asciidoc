[role="xpack"]
[[ccr-disaster-recovery-uni-directional-tutorial]]
=== Tutorial: Disaster recovery based on uni-directional {ccr}
++++
<titleabbrev>Uni-directional disaster recovery</titleabbrev>
++++


Learn how to failover and failback between two clusters based on
uni-directional {ccr}. The following tutorial is designed for mutable indices
(data need to be updated after write). If you have append-only data (logs,
metrics, observability and security events), you should follow
https://www.elastic.co/blog/bi-directional-replication-with-elasticsearch-cross-cluster-replication-ccr[Bi-directional
replication with Elasticsearch cross-cluster replication (CCR) blog] to set up
bi-directional {ccr} which automatically failover and failback without human
intervention.

* After setting up uni-directional {ccr}, data were replicated from `clusterA`
to `clusterB`.
* Failover. If `clusterA` goes offline, `clusterB` needs to "promote" follower
indices to regular indices to allow write operation. All ingestion will need to
be redirected to `clusterB`, this is controlled by the clients (Logstash, Beats,
Agents etc). 
* Failback. When `clusterA` is back online, it assumes the role of a follower
and replicating the leader indices from `clusterB`.

image::images/ccr-uni-directional-disaster-recovery.png[Uni-directional cross cluster replication failover and failback]

NOTE: {ccr-cap} provides functionality to replicate user-generated indices only.
{ccr-cap} isn't designed for replicating system-generated indices or snapshot
settings, and can't replicate {ilm-init} or {slm-init} policies across clusters.
Learn more in {ccr} <<ccr-limitations,limitations>>

==== Prerequisites
Before completing this tutorial,
<<ccr-getting-started-tutorial,set up cross cluster replication>> to connect two 
clusters and configure a leader and follower index. 

In this tutorial, `kibana_sample_data_ecommerce` is replicated from `clusterA` to `clusterB`.

[source,console]
----
### On clusterB ###
PUT _cluster/settings
{
  "persistent": {
    "cluster": {
      "remote": {
        "clusterA": {
          "mode": "proxy",
          "skip_unavailable": "true",
          "server_name": "clustera.es.australia-southeast1.gcp.elastic-cloud.com",
          "proxy_socket_connections": "18",
          "proxy_address": "clustera.es.australia-southeast1.gcp.elastic-cloud.com:9400"
        }
      }
    }
  }
}
PUT /kibana_sample_data_ecommerce/_ccr/follow
{
  "remote_cluster" : "clusterA",
  "leader_index" : "kibana_sample_data_ecommerce"
}
----
IMPORTANT: Writes (such as ingestion or updates) should occur only on the leader
index. Follower indices are read-only and will reject any writes.


==== Failover when `clusterA` is down

. Promote the follower indices in the `clusterB`
into regular indices so that it will be accepting writes. This can be achieved by:
* Pauses indexing following for the follower index.
* Closes the follower index.
* Unfollows the leader index.
* Opens the follower index (which is at this point is a regular index).
+
[source,console]
----
### On clusterB ###
POST /kibana_sample_data_ecommerce/_ccr/pause_follow
POST /kibana_sample_data_ecommerce/_close           
POST /kibana_sample_data_ecommerce/_ccr/unfollow    
POST /kibana_sample_data_ecommerce/_open
----

. On the Client (logstash, beats, agent) side, manually re-enable ingestion of
`kibana_sample_data_ecommerce` and redirect traffic to the `clusterB`. 
TIP: You should also redirect all search traffic to the `clusterB` cluster during
this time.

We can simulate this by ingesting document into this index. You should notice
this index is now writable.
+
[source,console]
----
### On clusterB ###
POST kibana_sample_data_ecommerce/_doc/
{
  "user":"kimchy"
}
----

==== Failback when `clusterA` comes back
`clusterB` becomes the new leader and `clusterA` becomes the follower. 
. Set up a remote `clusterB` on `clusterA`.

. Existing data need to be discard before you can turn any index into a
follower. Ensure the most up-to-date data is available on `clusterB` prior to
deleting the index on `clusterA`.  

. Create follower index on `clusterA`, to follow the leader index in
`clusterB`.  
+
[source,console]
----
### On clusterA ###
PUT _cluster/settings
{
  "persistent": {
    "cluster": {
      "remote": {
        "clusterB": {
          "mode": "proxy",
          "skip_unavailable": "true",
          "server_name": "clusterb.es.australia-southeast1.gcp.elastic-cloud.com",
          "proxy_socket_connections": "18",
          "proxy_address": "clusterb.es.australia-southeast1.gcp.elastic-cloud.com:9400"
        }
      }
    }
  }
}
DELETE kibana_sample_data_ecommerce

PUT /kibana_sample_data_ecommerce/_ccr/follow 
{ 
  "remote_cluster" : "clusterB", 
  "leader_index" : "kibana_sample_data_ecommerce" 
}
----
+

. You should now see updated documents from this index on the follower cluster.
+
[source,console]
----
### On clusterA ###
GET kibana_sample_data_ecommerce/_search?q=kimchy
----
